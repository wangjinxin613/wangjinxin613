---
feature: true
title: 去哪儿一面
date: 2024-05-06 11:42:32
tags:
	- 面试题
---

# 谈谈你对mvvm的理解

MVVM分为三个部分：分别是M（Model，模型层 ），V（View，视图层），VM（ViewModel，V与M连接的桥梁，也可以看作为控制器）

1、 M：模型层，主要负责业务数据相关；

2、 V：视图层，顾名思义，负视图相关，细分下来就是html+css层；

3、 VM：V与M沟通的桥梁，负责监听M或者V的修改，是实现MVVM双向绑定的要点；

MVVM支持双向绑定，意思就是当M层数据进行修改时，VM层会监测到变化，并且通知V层进行相应的修改，反之修改V层则会通知M层数据进行修改，以此也实现了视图与模型层的相互解耦；

![13.png](https://img.php.cn/upload/image/754/331/990/1647590664307648.png)

要实现一个mvvm的库，我们首先要理解清楚其实现的整体思路。先看看下图的流程：

![14.png](https://img.php.cn/upload/image/248/589/234/1647590672625585.png)

1.实现compile,进行模板的编译，包括编译元素（指令）、编译文本等，达到初始化视图的目的，并且还需要绑定好更新函数；

2.实现Observe,监听所有的数据，并对变化数据发布通知；

3.实现watcher,作为一个中枢，接收到observe发来的通知，并执行compile中相应的更新方法。

4.结合上述方法，向外暴露mvvm方法 

# 谈一谈对单页面应用的理解

**一、定义**
单页 Web 应用 (single-page application 简称为 SPA) 是一种特殊的 Web 应用。它将所有的活动局限于一个Web页面中，仅在该Web页面初始化时加载相应的HTML、JavaScript 和 CSS。一旦页面加载完成了，SPA不会因为用户的操作而进行页面的重新加载或跳转。取而代之的是利用 JavaScript 动态的变换HTML的内容，从而实现UI与用户的交互。由于避免了页面的重新加载，SPA 可以提供较为流畅的用户体验。

**二、优缺点**

单页Web程序的出现是富客户端发展的必然结果，但是该技术也是有些局限性，所以采用之前需要了解清楚它的优缺点。

1、优点：

1).良好的交互体验

用户不需要重新刷新页面，获取数据也是通过Ajax异步获取，页面显示流畅。

2).良好的前后端工作分离模式

单页Web应用可以和RESTful规约一起使用，通过REST API提供接口数据，并使用Ajax异步获取，这样有助于分离客户端和服务器端工作。更进一步，可以在客户端也可以分解为静态页面和页面交互两个部分。

3).减轻服务器压力

服务器只用出数据就可以，不用管展示逻辑和页面合成，吞吐能力会提高几倍；

4).共用一套后端程序代码
不用修改后端程序代码就可以同时用于Web界面、手机、平板等多种客户端；
2、缺点：

1).SEO难度较高

由于所有的内容都在一个页面中动态替换显示，所以在SEO上其有着天然的弱势，所以如果你的站点对SEO很看重，且要用单页应用，那么就做些静态页面给搜索引擎用吧。

2).前进、后退管理

由于单页Web应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理，当然此问题也有解决方案，比如利用URI中的散列+iframe实现。

3).初次加载耗时多

为实现单页Web应用功能及显示效果，需要在加载页面的时候将JavaScript、CSS统一加载，部分页面可以在需要的时候加载。所以必须对JavaScript及CSS代码进行合并压缩处理，如果使用第三方库，建议使用一些大公司的CDN，因此带宽的消耗是必然的

二、单页面应用实现的原理

1、基本实现原理：利用ajax请求替代了a标签的默认跳转，然后利用html5中的API修改了url，这项技术并没有特别标准的学名，大家都称呼为Pjax，意为PushState + Ajax。这并不完全准确，因为还有Hash + Ajax等方法

2、Pjax是一个优秀的解决方案，你有足够多的理由来使用它：

- 可以在页面切换间平滑过渡，增加Loading动画。
- 可以在各个页面间传递数据，不依赖URL。
- 可以选择性的保留状态，如音乐网站，切换页面时不会停止播放歌曲。
- 所有的标签都可以用来跳转，不仅仅是a标签。
- 避免了公共JS的反复执行，如无需在各个页面打开时都判断是否登录过等等。
- 减少了请求体积，节省流量，加快页面响应速度。
- 平滑降级到低版本浏览器上，对SEO也不会有影响。

3、深剖原理

1. 拦截a标签的默认跳转动作。
   2. 使用Ajax请求新页面。
   3. 将返回的Html替换到页面中。
   4. 使用HTML5的History API或者Url的Hash修改Url。

4、**HTML5 History API**

**history.pushState(state, title, url)**

pushState方法会将当前的url添加到历史记录中，然后修改当前url为新url。请注意，这个方法只会修改地址栏的Url显示，但并不会发出任何请求。我们正是基于此特性来实现Pjax。它有3个参数：

- state: 可以放任意你想放的数据，它将附加到新url上，作为该页面信息的一个补充。
- title: 顾名思义，就是document.title。不过这个参数目前并无作用，浏览器目前会选择忽略它。
- url: 新url，也就是你要显示在地址栏上的url。

**history.replaceState(state, title, url)**

replaceState方法与pushState大同小异，区别只在于pushState会将当前url添加到历史记录，之后再修改url，而replaceState只是修改url，不添加历史记录。

**window.onpopstate 事件**
一般来说，每当url变动时，popstate事件都会被触发。但若是调用pushState来修改url，该事件则不会触发，因此，我们可以把它用作浏览器的前进后退事件。该事件有一个参数，就是上文pushState方法的第一个参数state。

# hash 模式和 history 模式原理

https://blog.csdn.net/chenyajundd/article/details/136879644

# hash 模式怎么监测路由变化

```js
window.addEventListener('hashchange', function() {
    console.log('路由发生变化，当前hash为：', window.location.hash);
    // 在这里可以执行更新页面状态等操作
});
```

# vue2响应式原理

Vue 2的响应式原理主要基于其内部实现的观察者（Observer）和依赖收集（Dependency Collection）机制。以下是Vue 2响应式原理的详细解释：

1. 数据劫持

   ：

   - Vue在初始化时，会遍历data中的所有属性，并使用`Object.defineProperty`将这些属性转化为getter和setter。这意味着当你访问或修改这些属性时，Vue能够知道并做出反应。

2. Getter

   ：

   - 当某个属性被读取时，会触发getter。在getter中，Vue会收集对数据的依赖。具体来说，Vue会创建一个Watcher对象（也称为“依赖”或“观察者”），并将其与当前正在执行的组件实例关联起来。这个Watcher对象会被添加到该属性的依赖列表中。

3. Setter

   ：

   - 当某个属性被修改时，会触发setter。在setter中，Vue会监听到属性的变化。此时，Vue会遍历该属性的依赖列表，并通知列表中的每个Watcher对象执行更新操作。这些Watcher对象会触发对应的组件实例进行重新渲染，从而更新视图。

4. 依赖收集和触发更新

   ：

   - Watcher是Vue用来收集依赖和触发更新的核心机制。每个组件实例都会对应一个Watcher对象，用来管理该组件所依赖的属性。当组件的某个属性发生变化时，Vue会触发该属性的setter，进而触发依赖列表中所有Watcher对象的更新操作。

5. 计算属性和侦听器

   ：

   - Vue还提供了计算属性（computed properties）和侦听器（watchers）来增强响应式系统的能力。计算属性是基于它们的依赖进行缓存的，只有当相关依赖发生改变时才会重新求值。而侦听器则用于观察和响应Vue实例上数据的变化。

6. 深度监听

   ：

   - 对于嵌套的数据结构，Vue需要递归地应用`Object.defineProperty`来进行深度监听。然而，由于JavaScript的限制，Vue无法检测到对象属性的添加或删除。为了解决这个问题，Vue提供了`Vue.set`和`Vue.delete`方法来确保在添加或删除属性时能够触发视图更新。

7. 数组变更检测

   ：

   - 由于JavaScript数组的方法（如push、pop、shift、unshift、splice、sort、reverse等）会改变数组本身，而不是返回一个新的数组，Vue对这些方法进行了封装，以便在调用这些方法时能够触发视图更新。同时，Vue还提供了`Vue.observable`方法来创建可响应的数组或对象。

总的来说，Vue 2的响应式原理是通过数据劫持和依赖收集机制来实现的。这种机制使得当数据发生变化时，视图能够自动更新，从而实现了数据驱动的视图更新方式。

# Vue.set 原理

在初始化阶段，Vue 只会对已经存在的对象属性执行响应式处理。如果直接在已声明为响应式的对象上通过字面量方式添加新的属性（如 this.someObject.newProperty = ‘newValue’），新属性不会触发 getter 和 setter，因此不会被添加到响应系统中。

Vue.set 方法就是用来解决这个问题的。`它会在目标对象上创建一个新的属性，并确保这个属性同样经过了响应式处理，`即调用了 defineProperty 来设置 getter 和 setter。

###### 执行流程
Vue.set(target, key, value) 的执行流程是这样的：

首先，检查目标对象是否是 Vue 能够进行响应式处理的对象。
然后，在目标对象上定义一个新的属性 key，并使用 defineProperty 技术来确保它是可响应的，包括对它的读取和修改都能触发相关依赖的更新。
最后，将给定的 value 赋予新属性，并通知所有依赖于此对象的 Watcher 进行视图更新。

对于数组，Vue 提供了一系列变异方法（如 push、pop、shift、unshift、splice 等），这些方法可以自动触发视图更新。然而，当你需要直接修改数组的索引时（比如新增一个不存在的索引），也需要使用 Vue.set 或 vm.$set 来确保相应变化能够触发视图刷新。
Vue.set 方法的主要作用是向响应式对象中添加一个新属性，并确保新属性同样是响应式的。这个方法的实现原理依赖于 Vue 的数据响应式系统，通过 Object.defineProperty 方法将新属性添加到对象上，并设置 getter 和 setter。在使用 Vue.set 时，需要注意其适用范围和注意事项，以确保正确地使用。

# 简述vue diff 算法 流程

Vue.js 的 diff 算法（也称为“虚拟 DOM diffing”）是其性能优化的关键部分。当你更改数据并导致 Vue 组件重新渲染时，Vue 实际上不会直接操作真实的 DOM，而是先更新一个虚拟 DOM（Virtual DOM）的副本，然后比较新旧虚拟 DOM 树，找出需要变更的最小部分，并将这些变更应用到真实的 DOM 上。

以下是 Vue diff 算法的大致比对过程：

1. **同级比较**：
   Vue 只对同级的虚拟节点进行比较。如果旧节点和新节点不在同一层级，Vue 会直接销毁旧节点及其所有子节点，然后创建并插入新节点及其所有子节点。
2. **节点标识**：
   每个虚拟节点都有一个唯一的 key 属性作为标识。当新旧节点具有相同的 key 时，Vue 会认为它们是同一个节点，并尝试复用该节点。如果没有提供 key，Vue 会使用一种启发式方法来尝试就地复用节点，但这可能会导致不期望的副作用。
3. **节点类型**：
   在比较两个节点时，Vue 首先检查它们的节点类型是否相同（例如，都是元素节点、文本节点或注释节点）。如果节点类型不同，Vue 会认为这两个节点是不同的，并创建新的节点。
4. **属性更新**：
   如果两个节点的类型相同，Vue 会比较它们的属性，并更新需要变更的属性。这包括元素的类名、样式、事件监听器等。
5. **子节点比较**：
   对于元素节点，Vue 还需要比较其子节点。Vue 提供了两种策略来处理子节点的比较：
   - **双端比较**：从新旧节点的两端开始比较，直到找到第一个不匹配的节点。然后，Vue 会将新节点中剩余的部分作为插入操作，将旧节点中剩余的部分作为删除操作。
   - **最长递增子序列**：这是一种更复杂的策略，用于在子节点发生大量移动或重新排序时减少不必要的操作。Vue 会计算新旧节点列表的最长递增子序列（Longest Increasing Subsequence, LIS），并根据这个序列来移动和复用节点。
6. **更新 DOM**：
   在确定了需要变更的节点后，Vue 会将这些变更应用到真实的 DOM 上。由于 Vue 只操作了需要变更的节点，因此这个过程通常比直接操作整个 DOM 树要快得多。

需要注意的是，虽然 Vue 的 diff 算法非常高效，但它仍然是一个相对昂贵的操作。因此，在开发 Vue 应用时，我们应该尽量避免不必要的重新渲染，并尽量使用 v-show 而不是 v-if 来切换元素的显示状态（因为 v-show 只是切换 CSS 的 display 属性，而 v-if 会导致节点被销毁和重新创建）。

# vue data 为什么必须是一个函数

我们知道，Vue组件其实就是一个Vue实例。

JS中的实例是通过构造函数来创建的，每个构造函数可以new出很多个实例，那么每个实例都会继承原型上的方法或属性。

Vue的data数据其实是Vue原型上的属性，数据存在于内存当中。Vue为了保证每个实例上的data数据的独立性，规定了必须使用函数，而不是对象。

因为使用对象的话，每个实例（组件）上使用的data数据是相互影响的，这当然就不是我们想要的了。对象是对于内存地址的引用，直接定义个对象的话组件之间都会使用这个对象，这样会造成组件之间数据相互影响。

使用函数后，使用的是data()函数，data()函数中的this指向的是当前实例本身，就不会相互影响了。

而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。

# 性能方面做过哪些优化

编码阶段

尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher
v-if和v-for不能连用
如果需要使用v-for给每项元素绑定事件时使用事件代理
SPA 页面采用keep-alive缓存组件
在更多的情况下，使用v-if替代v-show
key保证唯一
使用路由懒加载、异步组件
防抖、节流
第三方模块按需导入
长列表滚动到可视区域动态加载
图片懒加载
SEO优化

服务端渲染SSR
预渲染
打包优化

压缩代码
Tree Shaking/Scope Hoisting
使用cdn加载第三方模块
多线程打包happypack
splitChunks抽离公共文件
sourceMap优化

# 前端发送网络请求时是否有同时最多连接数限制，为什么会有这种限制

https://blog.csdn.net/qq_33490514/article/details/115066232

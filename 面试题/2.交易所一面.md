1. Vue3和vue2有啥区别

```
1.双向数据绑定原理不同
Vue2 的双向数据绑定是利用ES5的一个APIObject.definePropert() 对数据进行劫持，结合发布订阅模式的方式来实现的。

Vue3 中使用ES6的Proxy API对数据代理。

Vue3 使用数据代理的优势有以下几点：1）definePropert 只能监听某个属性，不能对整个对象进行监听 2）可以省去for in，闭包等内容来提升效率（直接绑定整个对象即可）3）可以监听数组，不用再单独的对数组做特异性操作，Vue3可以检测到数组内部数据的变化

2.是否支持碎片
Vue2 不支持碎片。Vue3 支持碎片，就是说可以拥有多个根节点

3.API 类型不同
Vue2 使用选项类型api,选项型api 在代码里分割了不同的属性：data,computed,method等。

Vue3 使用合成型api,新的合成型api 能让我们使用方法来分割，相比于旧的api 使用属性来分组，这样代码会更加简便和整洁。

4定义数据变量和方法不同
Vue2是把数据放到了data 中，在 Vue2中 定义数据变量是data(){},创建的方法要在method:{}

Vue3 就需要使用一个新的setup()方法，此方法在组件初始化构造的时候触发。使用以下三个步骤来建立反应性数据：1）从vue 引入 reactive；2）使用 reactive ()方法来声明数据为响应性数据；3） 使用setup()方法来返回我们的响应性数据，从而template 可以获取这些响应性数据。

5.生命周期钩子函数不同
Vue2 中的生命周期：beforeCreate 组件创建之前；created 组建创建之后；beforeMount 组件挂载到页面之前执行；Mounted 组件挂载到页面之后执行，beforeUpdate 组件更新之前；updated组件更新之后

Vue3 中的生命周期：setup 开始创建组件；onBeforeMount 组件挂载到页面之前执行；onMounted 组件挂载到页面之后执行；onBeforeUpdate 组件更新之前；onUpdated 组件更新之后；

而且 Vue3 生命周期在调用前需要先进行引入。除了这些钩子函数外，Vue3 还增加了 onRenderTracked 和onRenderTriggered 函数。

6.父子传参不同
Vue2 父传子，用props ；子传父用事件Emitting Events。在Vue2 中，会调用this$emit 然后传入事件名和对象。

Vue3 父传子，用props;子传父用Emitting Events 。在Vue3 中的setup()中的第一参数content 对象中就有 emit,那么我们只要在setup()接收第二个参数中使用分解对象法取出emit 就可以在setup 方法中随意使用了。

7.指令与插槽不同
Vue2 中使用slot 可以直接使用slot ;v-for 与v-if 在Vue2中优先级高的是v-for 指令，而且不建议一起使用。

Vue3 中必须是使用v-slot的形式；vue 3中v-for 与v-if ，只会把当前v-if 当作v-for 的一个判断语句，不会相互冲突；

Vue3 中移除keyCode 作为v-on 的修饰符，当然也不支持config.keyCodes，取而代之的是使用键名来作为事件的修饰符来使用，于是Vue.config.keyCodes 也被弃用了-vue2我们在监听按键事件的时候，是可以通过在事件后面加上按键码来实现监听某一个按键的--mulingyuer.com/archives/831/# ；
————————————————
版权声明：本文为CSDN博主「多啦爱梦的梦想」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_56263402/article/details/128799953
```

2. 写h5和pc端有什么区别嘛

3. 怎么做首屏优化

```js
HTML优化：


将CSS放在里，可用来避免浏览器渲染的重复计算。
将JavaScript脚本放在的最后面，避免资源阻塞页面渲染。

减少DOM数量，减少浏览器渲染过程中的计算耗时。

通过合理使用浏览器GPU合成，提升浏览器渲染效率。

请求优化：


非核心资源异步加载，控制首屏请求数量；
静态文件进行缓存处理，合理设置缓存时效；

使用http2.0协议，来提升传输性能，减小请求阻塞；

网站开启GZIP优化，进行网页压缩处理；

对客户端进行资源预请求和预加载，比如使用预热Web容器。

渲染优化：


可以使用骨架屏进行页面预渲染；
对页面进行分片/分屏加载，将页面可见/可交互时间提前；

优化资源加载的顺序和粒度，仅加载需要的资源，通过异步加载方式加载剩余资源；

使用差异化服务，比如读写分离，对于不同场景按需加载其所需要的模块；

使用服务端直接渲染，减少页面二次请求和渲染的耗时。

静态资源优化:


针对JS、CSS 、HTML资源合并与压缩。
针对不同场景使用不同的图片格式。

使用雪碧图（CSS Sprites）和SVG，替代多个小图。

首屏预加载，非首屏懒加载。
```

4. h5的适配怎么做

```
rem适配
vm
calc
```

5.rem适配有啥缺点

```
（1）在奇葩的dpr设备上(设备像素比(简称dpr))表现效果不太好，比如一些华为的高端机型用rem布局会出现错乱。
（2）使用iframe引用也会出现问题。
（3）rem在多屏幕尺寸适配上与当前两大平台的设计哲学不一致。即大屏的出现到底是为了看得又大又清楚，还是为了看的更多的问题。

（4）rem在处理小数的时候会有误差，而且对小屏幕不友好。
————————————————
版权声明：本文为CSDN博主「more名奇妙」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/m0_67948827/article/details/127031751
```

6. 有做过老项目改造吗
7. 老项目改造有什么难点
8. 做过国际化嘛
9. Webpack做过哪些优化
10. 你的强项在哪
11. 谈谈你对redux的理解